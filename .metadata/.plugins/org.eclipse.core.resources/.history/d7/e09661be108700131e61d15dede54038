package perceptron;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import datastructure.Tuple;

public class Perceptron_algorithm {
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
//		ArrayList<ArrayList<Tuple>> data= new ArrayList<ArrayList<Tuple>>();
		File file=new File("/Users/liguifan/Desktop/data/rcv1-train.vw");
	
		
		BufferedReader reader=null;
		// 50000 is the dimension of the rcv1-train.vw 
		//double bias=0.1;
		int len=50000;
		double[] weight=new double[len];
		try{
			reader=new BufferedReader(new FileReader(file));
			String tempstr=null;
		
			while((tempstr=reader.readLine())!=null){
				double bias_term=extrac_bias_term(tempstr);
				ArrayList<Tuple> path=read_into_tuples(tempstr);
				int y_original=(int) tempstr.charAt(0)-48;
				// y convert the class 1 and 0 to 1 and -1;
				int y=(y_original==1)?1:-1;
				double response=sparse_dot_product(weight, path)-bias_term;
				// class type is 1 and 0;
				int y_est=(response>=0)?1:-1;
				if(y!=y_est){
					weight=update_weight(weight,y,path);
				}
			}
			reader.close();
		}
		catch (IOException e){
			e.printStackTrace();
		}finally{
			if(reader!=null){
				try{
					reader.close();
				}catch (IOException e1){
				}
			}
		}
		
		// Write the final weight into a file;
		for(int i = 0; i < weight.length; i++) {
		    try{ 
		    	BufferedWriter bw = new BufferedWriter(new FileWriter("/Users/liguifan/Desktop/data/weight-rcv1-train.txt", true));
		        String s;
		        s =Double.toString(weight[i]);
		        bw.write(s);
		        bw.write(" ");
		        bw.flush();
		    } catch(IOException ex) {}  
		}
		
		// give it a try.
		String line="1 |features f13:3.9656971e-02 f24:3.4781646e-02 f69:4.6296168e-02 f85:6.1853945e-02 f140:3.2349996e-02 f156:1.0290844e-01 f175:6.8493910e-02 f188:2.8366476e-02 f229:7.4871540e-02 f230:9.1505975e-02 f234:5.4200061e-02 f236:4.4855952e-02 f238:5.3422898e-02 f387:1.4059304e-01 f394:7.5131744e-02 f433:1.1118756e-01 f434:1.2540409e-01 f438:6.5452829e-02 f465:2.2644201e-01 f468:8.5926279e-02 f518:1.0214076e-01 f534:9.4191484e-02 f613:7.0990764e-02 f646:8.7701865e-02 f660:7.2289191e-02 f709:9.0660661e-02 f752:1.0580081e-01 f757:6.7965068e-02 f812:2.2685185e-01 f932:6.8250686e-02 f1028:4.8203137e-02 f1122:1.2381379e-01 f1160:1.3038123e-01 f1189:7.1542501e-02 f1530:9.2655659e-02 f1664:6.5160148e-02 f1865:8.5823394e-02 f2524:1.6407280e-01 f2525:1.1528353e-01 f2526:9.7131468e-02 f2536:5.7415009e-01 f2543:1.4978983e-01 f2848:1.0446861e-01 f3370:9.2423186e-02 f3960:1.5554591e-01 f7052:1.2632671e-01 f16893:1.9762035e-01 f24036:3.2674628e-01 f24303:2.2660980e-01 const:0.1";
		
		ArrayList<Tuple> pred=read_into_tuples(line);
		double b=extrac_bias_term(line);
		int y=predication(weight, pred, b);
		System.out.println("the predication for this is "+y);
		
		
		///////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////
		// Compute error on test data set.
		
		
	}
	
	
	
	
	
	//Test ok!
	// Read one original line and return all the tuples corresponding to every predictor in this line;
	public static ArrayList<Tuple> read_into_tuples(String line){
		String[] line1=line.split("features");
		String[] line2=line1[1].split("const:");
		String valid_line=line2[0].substring(1,line2[0].length());
		String[] arr=valid_line.split(" ");
		System.out.println(arr[0]);
		ArrayList<Tuple> set=new ArrayList<Tuple>();
		for(String single:arr){
			Tuple temp=extract_value(single);
			set.add(temp);
		}
		return set;
	}
	
	// test ok!
	// Extract every single term of that line;
	public static Tuple extract_value(String single){
		String new_str=single.substring(1,single.length());
		String[] arr=new_str.split(":");
		int index=Integer.parseInt(arr[0]);
		double value=Double.parseDouble(arr[1]);
		Tuple result=new Tuple(index,value);
		return result;
	}
	
	// test ok!
	public static double sparse_dot_product(double[] weight, ArrayList<Tuple> tuple){
		
		double sum=0;
		for(Tuple x:tuple){
			sum+=weight[x.index]*x.value;
		}
		return sum;
	}
	
	// test ok!
	public static double[] update_weight(double[] weight, int y, ArrayList<Tuple> tuple){
		for(Tuple x:tuple){
			weight[x.index]+=y*x.value;
		}
		return weight;
	}
	
	// test ok!
	// This is to predict
	public static int predication(double[] weight,ArrayList<Tuple> tuple, double b){
		int response;
		double t=sparse_dot_product(weight, tuple)-b;
		response=(t>=0)?1:-1;
		return response;
	}
	
	// test ok!
	// This is to extract the value of "const:value" as the bias term;
	public static double extrac_bias_term(String line){
		String[] line1=line.split("features");
		String[] line2=line1[1].split("const:");
		String const_term=line2[1];
		double bias_term=Double.parseDouble(const_term);
		return bias_term;
	}
}
